# S21_CHEET_SHEET
### Гайд по противодействию школе 21

## Компиляция и запуск
**gcc -std=c11 -Wall -Werror -Wextra -Wconversion -Warith-conversion file.c -o file.out & file.out**</br></br>
**-std=c11** задает компилятору стандарт С11, который не допускает применение пары forbidden functions</br>
**-Wall & -Wextra** подсвечивает дополнительные неточности в коде как возможные ошибки</br>
**-Werror** делает возможные ошибки a.k.a. предупреждения ошибками и фейлит процесс компиляции на этапе препроцессинга</br>
**-Wconversion & -Warith-conversion** делает ошибкой неявное приведение типов. Полазив вечером по флагам gcc подметил его, т.к. в некоторых заданиях используется неявное приведение. Условно тот же getchar возвращает значение типа int, а не char, и можно словить на этом ошибку. К тому же С относится к языкам статической типизации, а по сему считаю неявное приведение ошибкой и способ к лучшему написанию кода.</br>

## Проверка на валид ввода
Основная проверка, которая проста в освоении и проходит абсолютно все, что только возможно, имеет следующий вид</br>
```С
#include <stdio.h>

#define args_num 1 // количество аргументов внутри scanf или по-простому количество включений символа '%' внутри

int main() {
  int var;
  if(scanf("%i", &var) == args_num) {
    // ... something good
  } else {
    // ... meh 
  }
  return 0;
}
```
> P.S. вариант с **getchar() == '\n'** и **char c** делают лишние махинации с буфером дробной части числа и валятся автотестами. Простое друг хорошего, простейшее друг лучшего

## Работа с динамикой в СИ
**Основная моя функция**
```С
int **alloc_2d(int row, int column) {
    int **arr = malloc(row * column * sizeof(int) + row * sizeof(int*));
    int *ptr = (int*) (arr + row);
    for(int i = 0; i < row; i++) {
        arr[i] = ptr + i * column;
    }
    return arr;
}
```
Пример использования
```С
// somewhere in code
int **matrix = alloc_2d(row, column);
// some code
if (matrix != NULL) free(matrix);
// no leaks
// P.S. проверять при инициализации и освобождении ячейку памяти на NULL считается хорошим тоном, 
// т.к. помогает избежать лишних ошибок, если память не была выделена или уже освобождена где-то
```
Однажды на экзамене я не знал как работает реаллок, а он был мне нужен, так что была написана своя реализация)
```С
int *realloc_lacosta(int *data, int size, int old_size) {
    int *new = malloc(size * sizeof(int));
    for (int i = 0; i < old_size; i++) {
        new[i] = data[i];
    }
    free(data);
    return new;
}
```
> P.S. Работает при условии, что size > old_size, т.е. сайз по задумке вне функции где-то увеличивается на условно х2(унифицированный формат для оптимизации, а еще потому, что под капотом зачастую можно увидеть для увеличения операцию побитового сдвига, которая не тратит вычислительные мощности, т.к. результат уже известен системной шине, ибо идет изменение напрямую битового представления) и затем вызывается реаллок на новый size, а old_size играет роль индексов для копирования

## Что проверяют и используют автотесты?(теории заговора 21)
Вероятно всего автотесты построены через парсинг заранее готовых .txt файлов скриптом на сервере.</br>
Это обьясняет то, что они не дают на вход специальные символы прерывания потока ака процессорная термизация.</br>(**ctrl+c** условно прервет код и не даст ему завершиться = ошибка, но автотесты нормально кушают это)</br>
Дают много граничных случаев и вкидывают значения, которые крашат си по-математическим правилам. Любые операции с нулями имеют высокий порог багануться. Мб еще двоичное представление используется, хызы.</br>
Проверяют на соответствие стилям согласно **Google C формат**.</br>
Для стандартизации своего кода достаточно скопировать файл .clang-format из /materials/linters/ в рабочую директорию с *.c и прописать </br>
**clang-format -n file.c**.</br>
Проверяют на эффективность кода утилитой **cppcheck**. Показывает "лишние переменные", более близкие области определения переменных к месту их использования и тд в целях оптимизации</br>
**cppcheck --enable=all --suppress=missingIncludeSystem file.c file.h**</br>
Проверка на утечки "file.out" **valgrind**</br>
**valgrind --tool=memcheck --leak-check=yes file.out**</br>
> P.S. Данные по результатам первого экзамена и будет дополняться в процессе
